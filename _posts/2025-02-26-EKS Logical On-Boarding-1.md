---
layout: post
category: k8s
---

## EKS Logical On Boarding
### 1. kubernetes는 정확히 무엇인가요?
쿠버네티스는 **컨테이너를 쉽고 빠르게 배포 및 확장하고 관리를 자동화** 해주는 오픈소스 플랫폼입니다. 

### 2. kubernetes는 무엇으로 이루어져 있나요?
쿠버네티스를 배포하게 되면, **쿠버네티스 클러스터 형태**로 배포가 됩니다.  
클러스터 노드라고 하는 **워커 머신들의 집합**을 의미하며 모든 클러스터는 **최소 하나의 워커 노드**를 가지게 됩니다.  
</br>
**워커 노드는 Pod를 호스팅하는 목적**을 두고 있으며, **Control Plane은 Worker Node와 클러스터 내 Pod들을 관리**합니다.

### 3. Control Plane (Master Node) Components  
Control Plane (Master Node) 구성 요소는 **클러스터에 관한 전반적인 결정들을 수행하며 이벤트를 감지하고 반응**하도록 하는 요소들입니다.  
예를 들어 **Pod 스케줄링을 수행하여 파드들이 생성되는 것을 일정화**할 수 있으며, **Deployment의 Replicas 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 파드를 구동**시키는 역할을 합니다.  
</br></br>
위와 같이, Control Plane (Master Node) 구성 요소들은 **클러스터 내 어떠한 머신에서든지 동작 가능**하며, 대부분 Control Plane (Master Node)을 **동일한 컴퓨팅 머신상에 구성**하고, 사용자 컨테이너는 해당 컴퓨팅 머신에서 동작시키지 않습니다.  
아래 Control Plane (Master Node)의 **구성 요소들**에 대해 살펴보겠습니다.  
</br></br>
![Image](https://github.com/user-attachments/assets/bb9d1dd2-c72f-4719-8df1-9bf214486441)

#### 3.1 Kube-apiserver  
**API 서버는 쿠버네티스 API를 노출하는 핵심 요소**입니다.  
kube-apiserver는 **파드, 서비스, 컨트롤러 등을 검증하고 구성하는 역할**을 하며, **모든 구성 요소가 상호작용할 수 있도록 REST API를 제공하는 클러스터의 프론트엔드 역할**을 합니다.  
또한 **수평 확장이 가능하도록 설계**되어 있으며, 여러 인스턴스를 배포하여 **확장 및 트래픽을 균형 있게 조절**할 수 있습니다.

#### 3.2 ETCD  
**모든 클러스터 데이터를 저장하는 쿠버네티스의 데이터베이스**이며, **키-값 저장소**입니다.  
이러한 저장소가 **다운될 경우 치명적인 영향을 미치므로**, ETCD는 **RSM(복제 상태 머신, Replicated State Machine) 형태로 배포**됩니다.

**RSM(복제 상태 머신)**이란?  
분산 컴퓨팅 환경에서 몇 개의 서버가 다운되더라도 안정적으로 동작하도록 설계된 방법입니다.  
이는 **동일한 데이터를 여러 서버에 계속 복제(State Machine Replication)하여 유지**하는 구조입니다.

#### 3.3 kube-scheduler  
**새로 생성된, 노드가 배정되지 않은 파드를 감지하고, 실행할 노드를 선택**하는 요소입니다.  
스케줄링 결정을 위해 아래와 같은 요소들을 고려합니다.
- **리소스 요구 사항 및 전반적인 요구 사항**
- **하드웨어 & 소프트웨어/정책적 제약**
- **어피니티(affinity) 및 안티-어피니티(anti-affinity)**
- **데이터 지역성**
- **워크로드 간 간섭**
- **데드라인 요구사항** 등

#### 3.4 kube-controller-manager  
**컨트롤러 프로세스를 실행시키는 요소**입니다.  
각 컨트롤러들은 논리적으로 분리된 프로세스지만 **단일 바이너리로 컴파일되어 단일 프로세스 내에서 실행**됩니다.  
주요 컨트롤러는 다음과 같습니다.
- **Node Controller**: 노드가 다운될 경우 감지 및 대응
- **Job Controller**: 일회성 작업 감시 및 해당 작업을 수행하는 파드 관리
- **EndpointSlice Controller**: 서비스와 파드 간 연결성을 제공하기 위한 엔드포인트 슬라이스 오브젝트 관리
- **Service Account Controller**: 새로운 네임스페이스에 대한 기본 서비스 계정 생성

#### 3.5 cloud-controller-manager  
**클라우드별 관리 로직을 포함하는 요소**이며, 이를 통해 클러스터를 **클라우드 공급자의 API에 연결**할 수 있습니다.  
온프레미스 환경에서는 존재하지 않으며, 클라우드 환경에서는 아래 요소들에 의존성을 가질 수 있습니다.
- **Node Controller**: 클라우드에서 노드 상태를 확인하고 삭제 여부 판단
- **Route Controller**: 기본 클라우드 인프라에 경로 구성
- **Service Controller**: 클라우드 인프라에서 로드밸런서 생성 및 관리

</br></br>

> **쿠버네티스를 클라우드에 배포하는 것과 온프레미스에 배포하는 것의 차이점은?**  

✅ **클라우드 배포**  
- 대부분의 클라우드 제공업체에서 **SaaS 형태로 제공**  
- **빠른 배포, 확장, 관리가 용이**  
- **불필요한 컴퓨팅 리소스를 제거하여 비용 절감 가능**  

✅ **온프레미스 배포**  
- **폐쇄망 환경에서 서비스가 필요한 경우 유용** (예: 금융권, 보안이 중요한 기업)  
- **클라우드 관리자 없이 직접 운영 가능**  
- **현재 보유한 베어메탈 서버를 활용 가능**  

💡 **하이브리드 방식도 가능**  
- **온프레미스 서버를 기본으로 사용하고, 용량 초과 시 클라우드 활용**  
- **비용 절감 및 유연한 운영 가능**  

---

### 4. Node Components  
**노드 컴포넌트는 동작 중인 파드를 유지하고, 쿠버네티스 런타임 환경을 제공**하며, **모든 노드에서 동작**합니다. 노드 

#### 4.1 kubelet  
**각 노드에서 에이전트 형태로 실행되는 애플리케이션**이며, **파드 내부에서 컨테이너가 정상적으로 동작하도록 관리**합니다.  

kubelet은 **PodSpec을 기반으로 컨테이너가 명시된 대로 동작하는지 다양한 메커니즘을 통해 확인하고 이를 유지**하며, **컨테이너 런타임**(Docker, containerd 등)을 사용하여 **Pod의 컨테이너를 실제로 실행합니다.**


#### 4.2 kube-proxy  
**클러스터의 각 노드에서 실행되는 네트워크 프록시**로, **쿠버네티스의 서비스 개념을 구현하는 핵심 요소**입니다.  

**노드의 네트워크 규칙을 유지 관리**하여, 내부 네트워크 세션뿐만 아니라 **클러스터 외부에서 파드로의 네트워크 통신을 가능하게 함**  

운영 체제에서 **패킷 필터링 계층**이 지원되는 경우 이를 활용하여 네트워크 트래픽을 관리하며, 만약 지원되지 않는다면 **자체적으로 트래픽을 포워딩**하는 역할을 수행합니다.



#### 4.3 Pod 
**파드는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위**입니다.  
즉, **하나 이상의 컨테이너 그룹**을 의미합니다.

**컨테이너는 애플리케이션**을 의미하며, 이는 **완전한 애플리케이션의 일부 기능**일 수도 있고, **완전한 애플리케이션 그 자체**일 수도 있습니다.

**파드에 정의된 여러 개의 컨테이너는 하나의 완전한 애플리케이션으로 동작**합니다.  
단일 컨테이너 파드든, 다중 컨테이너 파드든 **애플리케이션을 실행하는 기본 단위가 바로 "파드"**입니다.


### 5 Control Plane & DataPlane은 어떻게 통신하나요?
쿠버네티스 클러스터에서 **Control Plane과 Data Plane 간의 통신**은 클러스터의 안정성과 보안을 위해 매우 중요합니다. 이러한 통신은 다음과 같은 두 가지 주요 경로로 이루어집니다:

1. **Control Plane에서 Data Plane로의 통신**:  
   - **kube-apiserver**는 각 노드의 **kubelet**과 **kube-proxy**를 대상으로 통신합니다.
   - **kube-apiserver**는 **HTTPS**를 통해 **kubelet의 `/exec` 엔드포인트**, **로그**, **포트 포워딩** 등을 호출합니다.
   - 이러한 통신은 기본적으로 **TLS**로 보호되며, 인증서 기반의 **클라이언트 인증**이 사용됩니다.

2. **Data Plane에서 Control Plane로의 통신**:  
   - 각 노드의 **kubelet**, **kube-proxy**, 그리고 **노드에서 실행되는 파드**는 **kube-apiserver**와 통신합니다.
   - **kubelet**은 주기적으로 **PodSpec**을 가져오고, 상태 보고를 위해 **kube-apiserver**에 접근합니다.
   - 이러한 접근은 일반적으로 **HTTPS**를 통해 이루어지며, **kubelet**은 **클라이언트 인증서** 또는 **Bearer 토큰**을 사용하여 인증합니다.


1. EKS의 kubeconfig는 어떤 구조인가요
- 그냥 kubernets를 사용햇을떄 kubeconfig와 eks로 구성된 클러스터와 연동 시 kubeconfig는 어떻게 다른가요?
- eks에서의 인증/인가는 어떻게 이루어지나요?
- 만든사람 이외에 유저에게 클러스터 권한을 어떻게 주나요?
- 참고: 아래 명령어를 통해 eks는 클러스터의 대한 kubeconfig을 가져올 수 있습니다

		aws eks update-kubeconfig

1. Pod는 배포 시 어디로 가냐요?
- nginx pod단 하나를 띄웟을떄 어디로 갈까요?
- deployment로 뿌리면 어떻게 달라지나요?
    - 배포 방법이 위 두개 뿐인가요?
- 배포 방법은 각각 어떨데 사용하나요?
- 내가 원하는 곳에 띄우는 방법은 없나요?
